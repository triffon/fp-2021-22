# Двоично наредено дърво

1. Да се дефинира тип `BST`, който да представлява двоично наредено дърво,
съдържащо стойности от произволен тип във възлите си. Да се дефинират следните
функции към него:

   ```haskell
   bstInsert :: (Ord a) => a -> BST a -> BST a -- добавяне на стойност в дървото
   ```

   ```haskell
   bstSearch :: (Ord a) => a -> BST a -> Bool -- търсене на стойност в дървото
   ```

   ```haskell
   bstSize :: BST a -> Int -- брой стойности в дървото
   ```

   ```haskell
   bstFromList :: (Ord a) => [a] -> BST a -- получаване на двоично наредено дърво от списък със стойности
   ```

   ```haskell
   bstToList :: BST a -> [a] -- получаване на списък с всички стойности в дървото
   ```

1. Да се дефинира функцията `bstSort(l)`, която сортира даденият списък от елементи, използвайки двоично наредено дърво.

1. Да се дефинира функцията `toBalancedTree(l)`, която създава
**балансирано** двоично **наредено** дърво от сортирания списък `l`.

1. Да се дефинира тип `Map`, който да представлява структурата от данни map,
реализирана с двоично наредено дърво. Да се дефинират следните функции към нея:

- Вмъкване на ключ със
стойност в дървото. Ако стойност за този ключ съществува, нека тя да бъде
заместена с новата.

    ```haskell
    mapInsert :: (Ord k) => k -> v -> Map k v -> Map k v
    ```

- Tърсене на стойност по ключ
в дървото (обърнете внимание на типа на връщане)

    ```haskell
    mapSearch :: (Ord k) => k -> Map k v -> Maybe v
    ```

- Брой наредени двойки (ключ, стойност) в дървото

    ```haskell
    mapSize :: Map k v -> Int
    ```

- Получаване на map от списък
от наредени двойки (ключ, стойност)

    ```haskell
    mapFromList :: (Ord k) => [(k, v)] -> Map k v
    ```

- Получаване на списък с всички наредени
двойки (ключ, стойност), съдържащи се в map

    ```haskell
    mapToList :: Map k v -> [(k, v)]
    ```
