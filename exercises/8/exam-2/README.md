
## Задачи за подготовка за второ контролно

1. Нека е даден списък от наредени двойки от числа, представляващи точки в равнината. Да се напише функция findPoint, която намира такава точка от списъка, за която сумата от квадратите на разстоянията до всички останали точки в списъка е максимална.

    Пример:  `findPoint [(2,8),(-2,4),(1,2),(-4,-1),(5,0)] → (-4,-1)`


1. Да се напише функция mostFrequent, която по даден списък от списъци от числа връща числото, което е сред най-често срещаните числа във всички списъци, ако такова има, или 0 иначе.

    Пример: `mostFrequent [[1,1,3,2],[1,1,5],[1,5],[1,1,1,3]] → 1`
    Пример: `mostFrequent [[1,1,3,2],[1,5,5],[1,5],[1,1,1,3]] → 0`


1. Да се напише функция extremum, която по даден списък от списъци от числа намира число, което е минимално или максимално във всеки от списъците, ако има такова, или 0 иначе.

    Пример: `extremum [[1,2,3,2],[3,5],[3,3],[1,1,3,3]] → 3`
    Пример: `extremum [[1,2,3,2],[2,3,5],[3,3],[2,2,3,3]] → 0`


1. Да се напише функция transformCount, която преобразува дърво с елементи цели числа в ново дърво със същата структура, в което всеки елемент е заменен с броя на елементите в поддървото с този корен в началното дърво.

    Бонус: transformCount да работи в O(n) време в най-лошия случай.

1. Да се напише функция grow t x, която по дадено двоично дърво от числа t получава ново, в което към всяко листо на t добавя по две нови листа със зададена стойност x.

1. Двоично дърво наричаме “пълно”, ако има 2n елемента на ниво n. Да се напише функция growingTrees, която генерира безкраен поток от пълни дървета с височини съответно 1, 2, 3,..., като всички елементи на ниво n са със стойност n.

1. В дърво от числа с произволен брой наследници “семейство” наричаме съвкупността от даден възел (“глава” на семейството) и всички негови деца.

    а) Две семейства наричаме “подобни”, ако множествата от числата им съвпадат. Да се напише функция similarFamilies, която по две дървета проверява дали семействата в корените им са подобни.

    б) Два възела наричаме “далечни роднини”, ако нито един от двата възела не е наследник на другия. Да се напише функция similarButDistant, която проверява дали в дадено дърво има две подобни семейства, чиито глави са далечни роднини.