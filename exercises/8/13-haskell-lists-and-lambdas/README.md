Haskell
=======

Ще упражним:

- рекурсия
- pattern matching на списъци и кортежи (tuples) `(a, b):xs`
- lambda `\x -> x + 1`
- range `[1,3...]`
- list comprehension `[x**2 | x <- [1..10]]`

Декларирайте типа на всяка функция, която дефинирате.

Списъци в Haskell
-----------------

1. Да се дефинира функция `elem(x, l)`, която
проверява дали елемента `x` присъства в списъка `l`.

2. Да се дефинира функция `reverse(l)`, която обръща списъка `l`.

3. Да се дефинира функция `map(f, l)`, която
прилага функцията `f` върху всеки елемент от списъка `l`.

4. Да се дефинира функция `filter(p, l)`, която
връща списък с всички елементи на `l`, които
удовлетворяват предиката `p`.

5. Да се дефинира функция `foldr(op, nullValue, l)`, която
редуцира (акумулира) елементите на списъка `l` чрез бинарната функция `op`
до една стойност, където `nullValue` е началната стойност на акумулатора.

6. Да се дефинира функция `sort(l)`, която сортира списъка `l`.
Използвайте Quick Sort или друг любим алгоритъм за сортиране.

Матрици
-------

7. Да се дефинира функция `column(m, i)`, която
намира `i`-тата по ред колона, броейки от нула, в матрицата `m`.

8. Да се дефинира функция `transpose(m)`, която
връща транспонираната матрица на `m`.

9. Да се дефинира функция `diagonal(m)`, която
връща главния диагонал на матрицата `m`.

10. Да се дефинира функция `diagonal2(m)`, която
връща втория диагонал на матрицата `m`.

11. Да се дефинира функция `foldm(op, nullValue, m)`, която
редуцира (акумулира) елементите на матрицата `m` чрез бинарната функция `op`
до една стойност, където `nullValue` е началната стойност на акумулатора.

Множества
---------

12. Да се дефинира функция `intersection(a, b)`, която
намира сечението на списъците `a` и `b`.

13. Да се дефинира функция `difference(a, b)`, която
намира разликата на двете множества (списъци) `a` и `b`, като
премахва срещанията на всички елементи на `b` от `a`.

14. Да се дефинира функция `product(a, b)`, която
намира декартовото произведение на двата списъка `a` и `b`
и връща списък от наредени двойки.

    Например, `product [1, 2, 3] [4, 5]` връща
    `[(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]`

15. Да се дефинира функция `triplets(n)`, която
връща списък от всички Питагорови тройки със сума по-малка от `n`.

    Например, `triplets 30` връща `[(3, 4, 5), (5, 12, 13), (6, 8, 10)]`

Асоциативни списъци
-------------------

16. Да се дефинира функция `zip(a, b)`, която
обединява поелементно списъците `a` и `b` в списък от наредени двойки.

    Например, `zip [1, 2, 3, 4, 5] ['a', 'b', 'c', 'd']` връща
    `[(1, 'а'), (2, 'b'), (3, 'c'), (4, 'd')]`.

17. Да се дефинира функция `histogram(l)`, която
връща хистограма на срещанията на всички елементи в `l`
под формата на списък от наредени двойки (кортежи).

    Например, `histogram [8, 7, 1, 7, 8, 2, 2, 8, 2, 7, 8, 1]`
    връща асоциативния списък `[(8, 4), (7, 3), (1, 2), (2, 3)]`.

18. Да се дефинира функция `runLengthEncode(l)`, която
кодира списъка `l` в асоциативен списък - списък от наредени двойки
`(<ключ>, <стойност>)`, където `<ключ>`-ът e пореден елемент от списъка `l`, а
`<стойност>`-та е колко пъти се повтаря елемента последователно.

    Например, `runLengthEncode [8, 7, 7, 2, 2, 2, 2, 3, 3, 2]`
    връща асоциативния списък `[(8, 1), (7, 2), (2, 4), (3, 2), (2, 1)]`.

Още списъци
-----------

Реализирайте следните функции върху списъци от [модула Prelude](https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#g:13):

1. `last :: [a] -> a`
1. `init :: [a] -> [a]`
1. `(!!) :: [a] -> Int -> a`

1. `take :: Int -> [a] -> [a]`
1. `drop :: Int -> [a] -> [a]`
1. `splitAt :: Int -> [a] -> ([a], [a])`
1. `chunk :: Int -> [a] -> [[a]]` - `chunk n l` разделя дадения списък l на списък от под-списъци с дължини `n`.

1. `takeWhile :: (a -> Bool) -> [a] -> [a]`
1. `dropWhile :: (a -> Bool) -> [a] -> [a]`

1. `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`
1. `unzip :: [(a, b)] -> ([a], [b])`

1. `scanr :: (a -> b -> b) -> b -> [a] -> [b]`

Реализирайте следните функции върху списъци от [модула Data.List](https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html)

1. `group :: Eq a => [a] -> [[a]]`
2. `inits :: [a] -> [[a]]`
3. `tails :: [a] -> [[a]]`

4. `subsequences :: [a] -> [[a]]`
5. `isSubsequenceOf :: Eq a => [a] -> [a] -> Bool`
6. `permutations :: [a] -> [[a]]`

7. `partition :: (a -> Bool) -> [a] -> ([a], [a])`
8. `find :: (a -> Bool) -> [a] -> Maybe a`
9. `findIndex :: (a -> Bool) -> [a] -> Maybe Int`
10. `findIndices :: (a -> Bool) -> [a] -> [Int]`

11. `nub :: Eq a => [a] -> [a]`
12. `delete :: Eq a => a -> [a] -> [a]`
13. `(\\) :: Eq a => [a] -> [a] -> [a]`
14. `union :: Eq a => [a] -> [a] -> [a]`
15. `intersect :: Eq a => [a] -> [a] -> [a]`

16. `sort :: Ord a => [a] -> [a]`
17. `sortOn :: Ord b => (a -> b) -> [a] -> [a]`
18. `insert :: Ord a => a -> [a] -> [a]`
