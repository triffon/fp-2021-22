# Повече задачи на Haskell (упр 9)

1. Да се напише функция `saySign`, която изписва на екрана какъв е знакът на подадения аргумент:
   ```hs
   saySign 1 -> "Positive"
   saySign -5 -> "Negative"
   saySign 0 -> "Zero"
   ```

3. Да се напише функцията `countRoots`, която приема три аргумента - коефициентите на квадратно уравнение - и изписва на екрана колко корена има то:
   ```hs
   countRoots 1 5 -6 -> "Two roots"
   ```

4. Да се напише функцията `sayRoots`, която приема три аргумента - коефициентите на квадратно уравнение - и изписва на екрана знаците на корените му:
   ```hs
   sayRoots 1 5 -6 -> "Positive and negative"
   ```

5. Да се напише функцията `cylinderVolume`, която изчислява обема на даден цилиндър по неговия радиус и височина
   ```hs
   cylinderVolume 2 5 -> 62.83185307179586
   ```

6. Да се напише функция `useless`, която приема четири аргумента и връща 1 ако някой от тях е нула и сумата на всички тях в противен случай.

7. Да се напише функция `power`, която степенува две числа по метода на бързото степенуване

3. Да се напише функция `modulus`, която приема комплексно число като наредена двойка от координатите си и изчислява неговия модул (разстоянието до нулата):
   ```hs
   modulus (3,4) -> 5
   ```

4. Да се напишат функции `complAdd`, `complSub` и `complMul`, които извършват съответните операции над комплексни числа, представени като наредени двойки от координатите си:
   ```hs
   complAdd (1,2) (-3,5) -> (-2,7)
   complSub (4,8) (2,-1) -> (2,9)
   complMul (3,5) (2,1) -> (1,13)
   ```

5. Да се напише функция `distance`, която намира разстоянието между две точки в равнината (отново наредени двойки):
   ```hs
   distance (-2,3) (1,7) -> 5
   distance (0,0) (1,1) -> 1.4142135623730951
   ```

6. Да се напише функция `replicate'`, която конструира списък от n повторения на даден обект:
   ```hs
   replicate' 5 10 -> [10,10,10,10,10]
   ```

7. Да се напише функция `take'`, която взима първите n елемента от даден списък:
   ```hs
   take' 3 [1..5] -> [1,2,3]
   take' 5 [10,20,30] -> [10,20,30]
   ```

8. Използвайте list comprehension, за да напишете следните функции:
   - `map'`
   - `filter'`
   - брой/сума на делителите на дадено число
   - проверка дали дадено число е просто
   - `descartes` - декартово произведение на два списъка

9. Да се генерира безкрайния списък `primes` от прости числа:
   ```hs
   take 5 primes -> [2,3,5,7,9]
   ```

10. Да се генерира безкрайния списък от прости числа по метода на ситото на Ератостен.

11. Да се напише функция `flip'`, която разменя аргументите на дадена двуаргументна функция и връща новополучената функция:
    ```hs
    (flip' div) 5 10 -> 2
    ```

12. Да се напише функция `takeWhile'`, която приема предикат и списък и връща тези елементи от началото на списъка, които изпълняват предиката:
    ```hs
    takeWhile' even [2,4,5,6,7,8] -> [2,4] -- забележете - функцията "спира" при първото срещнато нечетно число и не връща 6 или 8!
    ```

13. Да се напише функция `compress`, която по списък от стойности връща списък от наредени двойки от вида (<стойност>, <брой последователни срещания>):
    ```hs
    compress [1,1,2,3,3,3,4,2,2,2,2,1] -> [(1,2),(2,1),(3,3),(4,1),(2,4),(1,1)]
    compress "abba" -> [('a',1),('b',2),('a',1)]
    ```

14. Да се напише функция `maxRepeated`, която по списък от стойности връща дължината на най-дългия подсписък, съставен от еднакви стойности:
    ```hs
    maxRepeated [1,1,2,3,3,3,4,2,2,2,2,1,1] -> 4
    ```

15. Да се напише функция `makeSet`, която по даден списък връща всички негови уникални елементи (редът им няма значение):
    ```hs
    makeSet [1,1,2,3,3,3,4,2,2,2,1,1] -> [1,2,3,4]
    makeSet "abba" -> "ab"
    ```

16. Да се напише функция `histogram`, която за всяка уникална стойност от даден списък връща списък от наредени двойки от вида (<стойност>, <общ брой срещания>):
    ```hs
    histogram [1,1,2,3,3,3,4,2,2,2,1,1] -> [(1,4),(2,4),(3,3),(4,1)]
    ```

17. Да се напише функция `maxDistance`, която получава списък от точки (наредени двойки (Double, Double)) и връща дължината на най-дългата отсечка между някои две от тях.
    ```hs
    maxDistance [(-1.1, 1), (1.8, 2), (3, 1), (-1, -2)] -> 5
    ```

18. Да се напише функция `compositions`, която по дадена едноаргументна функция f съставя списък от всички ѝ композиции (започвайки от самата f)
    ```hs
    [ g 1 | g <- take 5 (compositions succ) ] -> [2,3,4,5,6]
    -- четем: създай списък от стойностите (g 1) за всяко g, взето измежду първите 5 елемента на композициите на функцията succ
    ```
