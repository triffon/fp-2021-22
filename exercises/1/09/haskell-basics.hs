-- Тези неща ще ви се карат :)

-- cover all cases!
{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}
-- use all your pattern matches!
{-# OPTIONS_GHC -fwarn-unused-matches #-}
-- write all your toplevel signatures!
{-# OPTIONS_GHC -fwarn-missing-signatures #-}
-- use different names!
{-# OPTIONS_GHC -fwarn-name-shadowing #-}
-- no incomplete patterns in lambdas!
{-# OPTIONS_GHC -fwarn-incomplete-uni-patterns #-}


-- Тук скривам някои функции,
-- за да може да правим дефиниции с имената им
import Prelude hiding (abs, gcd, lcd)

-- TODO: ghci + text editor
-- TODO: Полезни ресурси

-- ghci commands:
--  - :l(oad)
--  - :r(eload)
--  - :q(uit)
--  - :t(ype)
--  - :i(info)


-- В контраст със Scheme, Haskell е:
-- 0) Статично типизиран (няма имплицитно кастване!)
-- 1) С мързеливо оценяване (TODO: примери)
-- 2) Чист (без странични ефекти)
-- * Зависим от идентация (+ не харесва табулации)


-- Типове:
-- Bool - булев тип с константи True и False.
-- Char - Unicode символи.
-- Int - целочислен тип.
-- Integer - целочислен тип с неограничен размер.
-- Float - десетични числа с единична точност.
-- Double - десетични числа с двойна точност.

-- Съставни типове:
-- [a] - тип списък с произволна дължина и елементи от фиксиран тип a.
-- String = [Char] - низ (списък от символи).
-- (a,b,c) - тип кортеж (tuple) с фиксирана дължина и
--           произволни типове на компонентите.

-- Сравняваме неща с (==)

-- * Типовете (и техните конструктори) винаги започват с главна буква

-- някои основни синтактични конструкции:

-- if <cond> then <expr> else <expr>

-- ламбда функции: (\arg1 ... argn -> expr)
-- Пример:
-- square = (\ x -> x * x)

-- списък: [1,2,3]


-- Променливи:

-- Типова декларация на променлива
-- name :: type

-- Дефиниция на променлива
-- name = expression

num :: Int
num = 5

-- Haskell често се сеща и сам за типовите декларации.
-- Ние ще се стараем да ги пишем винаги :)


-- Функции (на 1 аргумент)

-- Типова декларации
-- name :: t1 -> t2
-- функция, която взима аргумент от тип t1
-- и връща резултат от тип t2

-- Дефиниция
-- name arg = expression
-- аргумента се свързва с името arg
-- и може да се използва в expression


-- * Имената на идентификаторите винаги започват с малка буква или "_".
-- Не могат да съдържат и "-", така че ще се придържаме към camel case

-- Можем и да имаме по-общи декларации (полиморфични)
-- Например функцията id
-- id :: a -> a
-- Тя взима нещо от тип a (а е само име) и връща нещо от същия тип
-- Пример:
-- map :: (a -> b) -> [a] -> [b]

succ' :: Int -> Int
succ' n = n + 1
-- Tук ' не е запазен символ,
-- често се използва за да избегнем използването на запазен идентификатор

-- А функции на повече аргументи?
-- name :: t1 -> ... -> tn -- функция, която взима n-1 аргумента
-- от съответните типове t1 ... tn-1 и връща резултат от тип tn

mult :: Int -> Int -> Int
mult a b = a * b

-- Прилагане на функции:
-- f x1 x2 .. xn, където f е идентификатора на функцията,
-- x1 .. xn са аргументи, а <space> e разделител.
-- Функциите на практика пак си се прилагат префиксно, но няма скоби!
-- Пример: mult 2 3

-- Операциите вече, се прилагат инфиксно, за наше щастие.
-- Пример: 1 + 2 * 3
-- Също така си имат съответните приоритети
-- * Можем и да ползваме скоби за да задаваме експлицитно приоритет
-- Прилагането на функция в Haskell е с най-висок приоритет пред други операции.

-- mult 2 3 + 7    -- 13
-- mult 2 (3 + 7)  -- 20

-- mult 2 succ 3   -- Грешка
-- mult бърза да се изпълни и като втори аргумент не вижда резултата от succ 3,
-- а функцията succ

-- Вече споменах как операциите се прилагат инфиксно.
-- можем всяка функция на 2 аргумента
-- да я приложим като бинарна операция.
-- Пример: 2 `mult` 3

-- от друга страна всеки оператор можем да го използваме като функция:
-- (+) 2 3

-- Всъщност ви излъгах, в Haskell има само функции на 1 аргумент
-- Нека разгледаме типа на следната функци
-- plus :: Int -> Int -> Int
-- Всъщност типа на plus би изглеждал по-скоро така:
-- plus :: Int -> (Int -> Int)
-- Приема число и връща функция на 1 аргумент: (plus 1) 2
-- Тоест функциите на повече аргументи са функции от по-висок ред.
-- (->) е дясно асоциативна операция
-- Заради начина по който се прилагат функциите в Haskell
-- няма нужда от грозни скоби, пишем просто:
-- plus 1 2
-- Това се нарича currying
-- TODO: примери
-- TODO: частично прилагане, curry/uncurry


------------
-- ЗАДАЧИ --
------------

-- Имплементирайте следните функции на Haskell.
-- Като пишете и типови декларации.

-- * Решете задачите за списъци без рекурсия,
-- т.е. само с готови функции за работа със списъци.

-- TODO: Hoogle

-- модул от n
abs = undefined

-- прилага дадена (едноаргументна) функция над даден аргумент
apply = undefined

-- за дадени две функции връща композицията им
compose = undefined

-- проверява дали първия списък е префикс на втория
-- Списъците са само от числа
prefix = undefined

-- проверява дали първия списък е суфикс на втория
-- Списъците са само от числа
suffix = undefined

-- по дадени списък xs, предикат p и функция f
-- връща списък от елементите на xs, за които е изпълнен предиката p,
-- като над тези елементи е приложена функцията f.
weakListComprehension = undefined

-- по даден списък xs и функция f
-- връща списък от тези елементи x на xs, за които f(x) е от xs
closed = undefined
