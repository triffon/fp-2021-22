#lang racket

; let ни дава да изброяваме локални дефиниции за даден израз
; може да е доста по-четимо и кратко от вложени извиквания на define
; Не можем да ползваме някоя локална дефиниция в тялото на друга
(let ((x 2)
      (y 3))
  (+ x y)) ; 5

; let* е като let, но можем да ползваме някоя дефиниция в тялото на
; друга, стига използваната да е на по-предна позиция в списъка
(let* ((x 2)
       (y (* x x)))
  (+ x y)) ; 6

; letrec е като let*, но можем да ползваме всяка локална дефиниция в
; тялото на всяка друга, без значение от реда
(letrec ((x (* y y))
         (y 3))
  (+ x y)) ; 12

;;;;;;;;;
; ГРАФИ ;
;;;;;;;;;

; Функциите от миналия път за асоциативни списъци
(define (make-alist fn keys)
  (map (lambda (key)
         (cons key (fn key)))
       keys))

(define (add-assoc key value alist)
  (cons (cons key value)
        alist))

(define (alist-keys alist)
  (map car alist))

(define (alist-values alist)
  (map cdr alist))

(define (alist-assoc key alist)
  (cond [(null? alist) '()]
        [(equal? (caar alist) key) (cdar alist)]
        [else (alist-assoc key (cdr alist))]))

(define (del-assoc key alist)
  (filter (lambda (alist-pair)
            (not (equal? (car alist-pair) key)))
          alist))

; Граф ще представяме като списък на съседство
; Тоест списък от списъци от върхове.
; За връх v ще дефинираме списък (v v1 .. vn)
; Където v1 до v1 са върховете до които v има ребро
; За всеки връх ще пазим такъв списък.
; Списъка от тези списъци ще е нашият граф.
;
; 1 --> 2
; |     |
; v     v
; 3 --> 4 --> 5
;
; Бихме го записали:
(define g
  '((1 2 3) ; 1 има ребро до 2 и 3
    (2 4)   ; 2 има ребро до 4
    (3 4)   ; 3 има ребро до 4
    (4 5)   ; 4 има ребро до 5
    (5)))    ; 5 няма ребра до други върхове

'() ; празен граф
'((1 2 3) (2)) ; Невалидно защото твърдим че 1 има ребро до 3,
               ; но не сме включили списък за реброто 3

; Как да си създадем граф?
; Може да го конструираме само с върхове и без ребра
(define (make-graph vs)
  (map list vs))

; Още няколко функции за работа с графи:

; проверява дали графа g е празен.
(define empty-graph? null?)

; Върховете на графа са точно първите елементи на подсписъците на g
; са точно върховете на g.
; Но ние вече имаме функция която има същата дефиниция
(define vertices alist-keys)

; За да добавим нов връх - добавяме списък от върха v,
; тоест той първоначално няма ребра до други върхове.
(define (add-vertex v g)
  (cons (list v) g))


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; Може да ползвате горните функции за асоциативни списъци
; Не забравяйте че списъците са двойки,
; тоест списък от списъци всъщност е асоциативен списък.
; (стига да няма празни списъци като елементи)

; Дефинирайте следните функции за работа с графи:

; Връща списък от всички ребра* на графа g.
; * т.е. двойки върхове (x . y), такива че има ребро от x към y
(define (edges g) void)

; Връща списък от децата на върха v в g.
(define (children v g) void)

; Проверява дали има ребро от върха u до върха v в g.
(define (edge? u v g) void)

; Връща списък от прилаганията на функцията f върху децата на v в g.
(define (map-children v f g) void)

; Връща първото дете на v в g, за което предиката p е верен.
(define (search-child v p g) void)

; Премахване на върха v от графа g заедно с ребрата до него.
(define (remove-vertex v g) void)

; Добавяне на ребро от u до v в g.
(define (add-edge u v g) void)

; Премахване на ребро от u до v в g.
(define (remove-edge u v g) void)


; Имплементирайте следните функции за графи.

; Връща степента на върха v в графа g.
(define (degree v g) void)

; Проверява дали графа g е симетричен.
(define (symmetric? g) void)

; Инвертира графа g. Тоест за всяко ребро (u,v) в g новият граф ще има реброто (v,u).
(define (invert g) void)

; Проверява дали има път между върховете u и v в графа g.
(define (path? u v g) void)

; Проверява дали графа g е ацикличен.
(define (acyclic? g) void)
